<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>L I G H T R U N N E R</title>
<style>
  body { margin:0; overflow:hidden; background:black; }
  canvas { display:block; }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const horizon = canvas.height * 0.25;
const gridSpacing = 60;

// Placeholder bike sprites (replace with PNGs)
const playerImg = new Image();
playerImg.src = "https://dummyimage.com/40x60/ff0000/000000&text=P"; // red bike
const botImg = new Image();
botImg.src = "https://dummyimage.com/40x60/00ffff/000000&text=B"; // cyan bike

let lastTap = 0;
let score = 0;
let gameOver = false;
let botSpawnTimer = 0;
let discSpawnTimer = 0;

const player = {
  x: canvas.width/2,
  y: canvas.height*0.8,
  size: 40,
  speed: 12,
  color: "red",
  discs: 0,
  trail: []
};

const bots = [];
const flyingDiscs = [];
const bombs = [];
const trails = []; // global trails (walls)

let knockbackTimer = 0;

// === CONTROLS ===
canvas.addEventListener("click", (e)=>{
  const now = Date.now();
  if(now - lastTap < 300 && player.discs > 0){
    flyingDiscs.push({x: player.x, y: player.y, size: 12, color:"yellow"});
    player.discs--;
  } else {
    if(e.clientX < canvas.width/2) player.x -= player.speed;
    else player.x += player.speed;
  }
  player.x = Math.max(20, Math.min(canvas.width-20, player.x));
  lastTap = now;
});

// === GRID ===
let gridOffset = 0;
function drawGrid(){
  ctx.strokeStyle = "lime";
  ctx.lineWidth = 1;
  gridOffset += 6;

  for(let i = 0; i < canvas.height; i += gridSpacing){
    const y = i + (gridOffset % gridSpacing);
    const scale = 1 - (y-horizon)/(canvas.height-horizon);
    if(scale <= 0) continue;
    ctx.beginPath();
    const left = canvas.width*0.25*(1-scale);
    const right = canvas.width - canvas.width*0.25*(1-scale);
    ctx.moveTo(left,y);
    ctx.lineTo(right,y);
    ctx.stroke();
  }

  for(let i=0;i<canvas.width;i+=gridSpacing){
    ctx.beginPath();
    ctx.moveTo(i, canvas.height);
    ctx.lineTo(canvas.width/2, horizon);
    ctx.stroke();
  }
}

// === TRAILS ===
function drawTrail(trail, color, width){
  ctx.strokeStyle = color;
  ctx.lineWidth = width;
  ctx.beginPath();
  for(let i=0;i<trail.length;i++){
    const t = trail[i];
    if(i===0) ctx.moveTo(t.x, t.y);
    else ctx.lineTo(t.x, t.y);
  }
  ctx.stroke();
}

// === PLAYER ===
function updatePlayer(){
  player.trail.push({x:player.x, y:player.y});
  trails.push({x:player.x, y:player.y, color:player.color, owner:"player"});
}

function drawPlayer(){
  drawTrail(player.trail, player.color, 12);
  ctx.drawImage(playerImg, player.x-20, player.y-30, 40, 60);
}

// === BOTS ===
function spawnBot(){
  const x = Math.random()*(canvas.width-100)+50;
  bots.push({x:x, y:horizon+40, size:40, color:"cyan", trail:[], alive:true});
}

function updateBots(){
  bots.forEach(bot=>{
    if(!bot.alive) return;

    bot.y += (knockbackTimer>0? 2 : 6);
    if(bot.x < player.x) bot.x += 2;
    if(bot.x > player.x) bot.x -= 2;

    bot.trail.push({x:bot.x,y:bot.y});
    trails.push({x:bot.x, y:bot.y, color:bot.color, owner:bot});

    // check collision with trails
    for(let i=0;i<trails.length;i++){
      const t = trails[i];
      if(t.owner === bot) continue; // ignore own newest segment, check older
      const dx = bot.x - t.x;
      const dy = bot.y - t.y;
      if(Math.sqrt(dx*dx+dy*dy) < 12){
        bot.alive = false;
        bombs.push({x:bot.x, y:bot.y, size:20, active:true});
        break;
      }
    }
  });

  // cleanup offscreen
  for(let i=bots.length-1;i>=0;i--){
    if(bots[i].y>canvas.height){
      bombs.push({x:bots[i].x, y:bots[i].y, size:20, active:true});
      bots.splice(i,1);
    }
  }
}

function drawBots(){
  bots.forEach(bot=>{
    if(!bot.alive) return;
    drawTrail(bot.trail, "cyan", 12);
    ctx.drawImage(botImg, bot.x-20, bot.y-30, 40, 60);
  });
}

// === BOMBS ===
function drawBombs(){
  bombs.forEach(b=>{
    ctx.fillStyle="orange";
    ctx.beginPath();
    ctx.arc(b.x,b.y,b.size,0,Math.PI*2);
    ctx.fill();
  });
}

// === DISCS ===
function updateDiscs(){
  flyingDiscs.forEach(fd=>fd.y -= 15);

  for(let i=flyingDiscs.length-1;i>=0;i--){
    const fd = flyingDiscs[i];
    for(let j=bots.length-1;j>=0;j--){
      const b = bots[j];
      if(!b.alive) continue;
      const dx=fd.x-b.x, dy=fd.y-b.y;
      if(Math.sqrt(dx*dx+dy*dy) < 30){
        b.alive=false;
        bombs.push({x:b.x,y:b.y,size:20,active:true});
        flyingDiscs.splice(i,1);
        break;
      }
    }
    for(let j=bombs.length-1;j>=0;j--){
      const bo = bombs[j];
      const dx=fd.x-bo.x, dy=fd.y-bo.y;
      if(Math.sqrt(dx*dx+dy*dy)<bo.size){
        flyingDiscs.splice(i,1);
        knockbackTimer = 600;
        bombs.splice(j,1);
        break;
      }
    }
    if(fd && fd.y<0) flyingDiscs.splice(i,1);
  }
}

function drawDiscs(){
  flyingDiscs.forEach(fd=>{
    ctx.fillStyle=fd.color;
    ctx.beginPath();
    ctx.arc(fd.x,fd.y,fd.size,0,Math.PI*2);
    ctx.fill();
  });
}

// === COLLISIONS ===
function checkTrailCollision(){
  for(let i=0;i<trails.length;i++){
    const t = trails[i];
    if(t.color === player.color) continue; // ignore own red trail
    const dx = player.x - t.x;
    const dy = player.y - t.y;
    if(Math.sqrt(dx*dx+dy*dy) < 12){
      gameOver = true;
      return;
    }
  }
}

// === HUD ===
function drawHUD(){
  ctx.fillStyle="white";
  ctx.font="24px Arial";
  ctx.fillText(`Score: ${score} | Discs: ${player.discs}`,20,40);
  if(knockbackTimer>0){
    ctx.fillStyle="yellow";
    ctx.fillText("KNOCKBACK ACTIVE!", canvas.width/2-100, 40);
  }
}

// === GAME LOOP ===
function gameLoop(){
  if(gameOver){
    ctx.fillStyle="white";
    ctx.font="48px Arial";
    ctx.fillText("GAME OVER",canvas.width/2-150,canvas.height/2);
    ctx.fillText(`Score: ${score}`,canvas.width/2-80,canvas.height/2+60);
    return;
  }

  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawGrid();
  updatePlayer();
  drawPlayer();

  if(botSpawnTimer<=0){spawnBot();botSpawnTimer=60;} else botSpawnTimer--;
  if(discSpawnTimer<=0){player.discs++;discSpawnTimer=300;} else discSpawnTimer--;

  updateBots();
  drawBots();
  updateDiscs();
  drawDiscs();
  drawBombs();
  checkTrailCollision();

  drawHUD();
  score++;
  if(knockbackTimer>0) knockbackTimer--;

  requestAnimationFrame(gameLoop);
}
gameLoop();
</script>
</body>
</html>
