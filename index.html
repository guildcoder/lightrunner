<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>L I G H T R U N N E R</title>
<style>
  body { margin:0; overflow:hidden; background:black; }
  canvas { display:block; }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const horizon = canvas.height * 0.25;
const gridSpacing = 60;

// Load local bike images
const playerImg = new Image();
playerImg.src = "assets/redbike.png";   // red bike
const botImg = new Image();
botImg.src = "assets/cyanbike.png";    // cyan bike

let lastTap = 0;
let score = 0;
let gameOver = false;
let botSpawnTimer = 0;

const player = {
  x: canvas.width/2,
  y: canvas.height*0.8,
  size: 40,
  speed: 12,
  color: "red",
  trail: []
};

const bots = [];
const bombs = [];
const trails = []; // global trail "walls"
let knockbackTimer = 0;

// === CONTROLS ===
canvas.addEventListener("click", (e)=>{
  const now = Date.now();
  if(e.clientX < canvas.width/2) player.x -= player.speed;
  else player.x += player.speed;
  player.x = Math.max(20, Math.min(canvas.width-20, player.x));
  lastTap = now;
});

// === GRID ===
let gridOffset = 0;
function drawGrid(){
  ctx.strokeStyle = "lime";
  ctx.lineWidth = 1;
  gridOffset += 6;

  // Horizontal lines (perspective shrink)
  for(let i = horizon; i < canvas.height; i += gridSpacing){
    const y = i + (gridOffset % gridSpacing);
    if(y < horizon) continue;
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(canvas.width, y);
    ctx.stroke();
  }

  // Vertical perspective lines
  for(let i = 0; i <= canvas.width; i += gridSpacing){
    ctx.beginPath();
    ctx.moveTo(i, canvas.height);
    ctx.lineTo(canvas.width/2, horizon);
    ctx.stroke();
  }
}

// === TRAILS ===
function drawTrail(trail, color, width){
  ctx.strokeStyle = color;
  ctx.lineWidth = width;
  ctx.beginPath();
  for(let i=0;i<trail.length;i++){
    const t = trail[i];
    if(i===0) ctx.moveTo(t.x, t.y);
    else ctx.lineTo(t.x, t.y);
  }
  ctx.stroke();
}

// === PLAYER ===
function updatePlayer(){
  // Straight-down trail from current position
  player.trail = [];
  for(let y = player.y; y < canvas.height; y += 20){
    player.trail.push({x: player.x, y: y});
  }
  trails.push({x: player.x, y: player.y, color: player.color, owner: "player"});
}

function drawPlayer(){
  drawTrail(player.trail, player.color, 12);
  ctx.drawImage(playerImg, player.x-20, player.y-30, 40, 60);
}

// === BOTS ===
function spawnBot(){
  const x = Math.random()*(canvas.width-100)+50;
  bots.push({x:x, y:horizon+40, size:40, color:"cyan", trail:[], alive:true});
}

function updateBots(){
  bots.forEach(bot=>{
    if(!bot.alive) return;

    bot.y += (knockbackTimer>0? 2 : 6);
    if(bot.x < player.x) bot.x += 2;
    if(bot.x > player.x) bot.x -= 2;

    bot.trail.push({x:bot.x,y:bot.y});
    trails.push({x:bot.x, y:bot.y, color:bot.color, owner:bot});

    // check collision with trails
    for(let i=0;i<trails.length;i++){
      const t = trails[i];
      if(t.owner === bot) continue;
      const dx = bot.x - t.x;
      const dy = bot.y - t.y;
      if(Math.sqrt(dx*dx+dy*dy) < 12){
        bot.alive = false;
        bombs.push({x:bot.x, y:bot.y, size:20, active:true});
        break;
      }
    }
  });

  // cleanup offscreen
  for(let i=bots.length-1;i>=0;i--){
    if(bots[i].y>canvas.height){
      bombs.push({x:bots[i].x, y:bots[i].y, size:20, active:true});
      bots.splice(i,1);
    }
  }
}

function drawBots(){
  bots.forEach(bot=>{
    if(!bot.alive) return;
    drawTrail(bot.trail, "cyan", 12);
    ctx.drawImage(botImg, bot.x-20, bot.y-30, 40, 60);
  });
}


// === COLLISIONS ===
function checkTrailCollision(){
  for(let i=0;i<trails.length;i++){
    const t = trails[i];
    if(t.color === player.color) continue; // ignore own red trail
    const dx = player.x - t.x;
    const dy = player.y - t.y;
    if(Math.sqrt(dx*dx+dy*dy) < 12){
      gameOver = true;
      return;
    }
  }
}

// === HUD ===
function drawHUD(){
  ctx.fillStyle="white";
  ctx.font="24px Arial";
  ctx.fillText(`Score: ${score}`,20,40);
  if(knockbackTimer>0){
    ctx.fillStyle="yellow";
    ctx.fillText("KNOCKBACK ACTIVE!", canvas.width/2-100, 40);
  }
}

// === GAME LOOP ===
function gameLoop(){
  if(gameOver){
    ctx.fillStyle="white";
    ctx.font="48px Arial";
    ctx.fillText("GAME OVER",canvas.width/2-150,canvas.height/2);
    ctx.fillText(`Score: ${score}`,canvas.width/2-80,canvas.height/2+60);
    return;
  }

  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawGrid();
  updatePlayer();
  drawPlayer();

  if(botSpawnTimer<=0){spawnBot();botSpawnTimer=60;} else botSpawnTimer--;

  updateBots();
  drawBots();
  drawBombs();
  checkTrailCollision();

  drawHUD();
  score++;
  if(knockbackTimer>0) knockbackTimer--;

  requestAnimationFrame(gameLoop);
}
gameLoop();
</script>
</body>
</html>
