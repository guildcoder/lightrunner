<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>L I G H T R U N N E R</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');
html,body{margin:0;padding:0;overflow:hidden;height:100%;background:black;font-family:'Share Tech Mono', monospace;}
canvas{display:block;}
#menu{
  position:absolute;top:0;left:0;width:100%;height:100%;
  display:flex;flex-direction:column;justify-content:center;align-items:center;
  background: rgba(0,0,0,0.85); z-index:10;color:white;
}
#menu input,#menu select,#menu button{
  margin:8px;padding:12px;font-size:18px;
  background:#111;border:2px solid cyan;color:white;border-radius:6px;
  text-shadow:0 0 5px cyan;
  cursor:pointer;transition:0.2s;
}
#menu input:focus,#menu select:focus,#menu button:hover{
  border-color:#0ff;text-shadow:0 0 10px #0ff;outline:none;
}
#title{
  font-size:72px;color:cyan;font-weight:bold;
  animation:bob 1.5s infinite alternate;
  margin-bottom:20px;
  text-shadow:0 0 15px cyan,0 0 30px cyan;
}
@keyframes bob{0%{transform:translateY(0px);}100%{transform:translateY(20px);}}
#hud{position:absolute;top:10px;left:10px;color:white;font-weight:bold;font-size:20px;z-index:5;}
</style>
</head>
<body>
<div id="menu">
  <div id="title">Tron Temple Run</div>
  <input id="playerName" placeholder="Enter your name" maxlength="12"/>
  <select id="bikeColor">
    <option value="cyan">Cyan</option>
    <option value="magenta">Magenta</option>
    <option value="yellow">Yellow</option>
    <option value="lime">Lime</option>
    <option value="blue">Blue</option>
    <option value="red">Red</option>
    <option value="green">Green</option>
  </select>
  <button id="startBtn">Run!</button>
  <div style="margin-top:10px;font-size:14px;opacity:0.8;">
    Controls: A/D to change lane, W/S to speed up/slow down, Space to jump
  </div>
</div>
<div id="hud"></div>
<canvas id="gameCanvas"></canvas>

<script>
const canvas=document.getElementById('gameCanvas');
const ctx=canvas.getContext('2d');
let width=canvas.width=window.innerWidth;
let height=canvas.height=window.innerHeight;
const hud=document.getElementById('hud');

let gameRunning=false;
let distance=0,score=0,speed=8;
const GRAVITY=0.8;
const LANE_COUNT=3,LANE_WIDTH=width/6;
const BOT_START_DELAY=500; // distance before bots appear

let player,bots=[],obstacles=[],projectiles=[],keys={a:false,d:false,w:false,s:false,space:false};

// --- Classes ---
class Bike{
  constructor(lane,color,name,isBot=false){
    this.lane=lane;
    this.color=color; this.name=name;
    this.isBot=isBot; this.alive=true;
    this.y=height-150; this.x=this.laneToX(lane);
    this.z=0; this.vy=0; this.onGround=true;
    this.attackCooldown=0;
  }
  laneToX(lane){return width/2 + (lane-1)*LANE_WIDTH;}
  move(){
    if(!this.alive)return;

    // Forward movement
    if(!this.isBot){
      if(keys.w)this.z += speed;
      if(keys.s)this.z -= speed*0.7;
      if(keys.a && this.lane>0)this.lane--; 
      if(keys.d && this.lane<LANE_COUNT-1)this.lane++;
      this.x=this.laneToX(this.lane);
      if(keys.space && this.onGround){this.vy=-15; this.onGround=false; keys.space=false;}
    } else {
      if(distance<BOT_START_DELAY) return; // Wait before chasing
      // AI chasing player
      if(this.z < player.z + 200)this.z += speed*0.9;
      if(this.lane < player.lane)this.lane++;
      else if(this.lane > player.lane)this.lane--;
      this.x=this.laneToX(this.lane);

      // Fire projectile occasionally
      if(this.attackCooldown<=0 && Math.random()<0.01){
        projectiles.push(new Projectile(this.x,this.y-50,this.z+50,this.color,false));
        this.attackCooldown = 100;
      }
      this.attackCooldown--;
    }

    // Jump & gravity
    this.y += this.vy;
    this.vy += GRAVITY;
    if(this.y>=height-150){this.y=height-150; this.vy=0; this.onGround=true;}

    // Collision with obstacles
    obstacles.forEach(obs=>{
      if(this.lane===obs.lane && Math.abs(this.z-obs.z)<50 && this.y>=height-150-obs.height){
        if(!this.isBot)this.alive=false;
      }
    });
  }
  draw(){
    let scale = 1 + ((this.z-player.z)/1000);

    // Draw rectangle base
    let rectHeight = 30*scale, rectWidth = 20*scale;
    let rectX = this.x - rectWidth/2;
    let rectY = this.y - ((this.z-player.z)/5) - rectHeight;

    ctx.fillStyle=this.color;
    ctx.shadowBlur=15; ctx.shadowColor=this.color;
    ctx.fillRect(rectX,rectY,rectWidth,rectHeight);

    // Draw forward-pointing triangle on top
    ctx.beginPath();
    ctx.moveTo(this.x, rectY - 20*scale);
    ctx.lineTo(this.x - rectWidth/2, rectY);
    ctx.lineTo(this.x + rectWidth/2, rectY);
    ctx.closePath();
    ctx.fill();
    ctx.shadowBlur=0;
  }
}

class Obstacle{
  constructor(lane,z){
    this.lane=lane; this.z=z;
    this.height=60;
    this.width=LANE_WIDTH*0.8;
  }
  draw(){
    let screenY = height - 150 - ((this.z - player.z)/5);
    ctx.fillStyle='red';
    ctx.fillRect(width/2 + (this.lane-1)*LANE_WIDTH - this.width/2,screenY - this.height,this.width,this.height);
  }
}

class Projectile{
  constructor(x,y,z,color,playerShot){
    this.x=x; this.y=y; this.z=z; this.color=color; this.playerShot=playerShot;
  }
  move(){this.z += this.playerShot?speed*2:-speed*2;}
  draw(){
    let screenY = this.y - ((this.z - player.z)/5);
    ctx.fillStyle=this.color;
    ctx.beginPath();
    ctx.arc(this.x,screenY,8,0,Math.PI*2);
    ctx.fill();
  }
  checkCollision(){
    if(!player.alive)return;
    if(!this.playerShot && Math.abs(this.z-player.z)<20 && Math.abs(this.x-player.x)<30){
      player.alive=false;
    }
  }
}

// --- Game Functions ---
function startGame(name,color){
  gameRunning=true; distance=0;score=0; speed=8;
  player=new Bike(1,color,name,false);
  bots=[new Bike(0,'red','Bot1',true), new Bike(2,'magenta','Bot2',true)];
  obstacles=[]; projectiles=[];
  loop();
}

function generateObstacles(){
  if(Math.random()<0.02){
    let lane=Math.floor(Math.random()*LANE_COUNT);
    obstacles.push(new Obstacle(lane,player.z + 800 + Math.random()*400));
  }
}

function update(){
  if(!player.alive)return;
  player.move();
  bots.forEach(b=>b.move());
  projectiles.forEach(p=>{p.move(); p.checkCollision();});
  distance += speed;
  score=Math.floor(distance/10);
  speed += 0.0005; // Gradually increase speed
  generateObstacles();
}

function draw(){
  ctx.clearRect(0,0,width,height);

  // Draw lanes
  for(let lane=0; lane<LANE_COUNT; lane++){
    ctx.fillStyle=lane===1?'rgba(0,255,255,0.1)':'rgba(255,255,255,0.05)';
    ctx.fillRect(width/2 + (lane-1)*LANE_WIDTH - LANE_WIDTH/2,0,LANE_WIDTH,height);
  }

  // Draw obstacles
  obstacles.forEach(obs=>obs.draw());

  // Draw projectiles
  projectiles.forEach(p=>p.draw());

  // Draw bikes
  player.draw();
  bots.forEach(b=>b.draw());

  hud.innerText=`Score: ${score}`;
}

function loop(){
  if(!gameRunning)return;
  requestAnimationFrame(loop);
  update();
  draw();
}

// --- Input ---
document.addEventListener('keydown',e=>{
  if(e.key==='a')keys.a=true;
  if(e.key==='d')keys.d=true;
  if(e.key==='w')keys.w=true;
  if(e.key==='s')keys.s=true;
  if(e.key===' ')keys.space=true;
});
document.addEventListener('keyup',e=>{
  if(e.key==='a')keys.a=false;
  if(e.key==='d')keys.d=false;
  if(e.key==='w')keys.w=false;
  if(e.key==='s')keys.s=false;
  if(e.key===' ')keys.space=false;
});

// --- Start button ---
document.getElementById('startBtn').addEventListener('click',()=>{
  const name=document.getElementById('playerName').value||'Runner';
  const color=document.getElementById('bikeColor').value||'cyan';
  document.getElementById('menu').style.display='none';
  startGame(name,color);
});

window.addEventListener('resize',()=>{width=canvas.width=window.innerWidth;height=canvas.height=window.innerHeight;});
</script>
</body>
</html>
